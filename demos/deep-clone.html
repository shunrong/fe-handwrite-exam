<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深拷贝实现演示</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .demo-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .demo-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #17a2b8;
        }
        
        .demo-section h2 {
            color: #17a2b8;
            margin-bottom: 15px;
        }
        
        .test-button {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background 0.3s;
        }
        
        .test-button:hover {
            background: #138496;
        }
        
        .test-button.danger {
            background: #dc3545;
        }
        
        .test-button.danger:hover {
            background: #c82333;
        }
        
        .result {
            background: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .json-viewer {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 14px;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #dee2e6;
        }
        
        .comparison-item h3 {
            margin: 0 0 10px 0;
            color: #495057;
        }
        
        .performance-test {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .performance-result {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .performance-item {
            background: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid #ffeaa7;
        }
        
        .performance-value {
            font-size: 18px;
            font-weight: bold;
            color: #856404;
        }
        
        .performance-label {
            font-size: 12px;
            color: #856404;
        }
        
        .back-link {
            display: inline-block;
            color: #007bff;
            text-decoration: none;
            margin-bottom: 20px;
            padding: 8px 15px;
            border: 1px solid #007bff;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        .back-link:hover {
            background: #007bff;
            color: white;
        }
        
        .warning {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← 返回首页</a>
    
    <div class="demo-container">
        <h1>🔄 深拷贝实现演示</h1>
        
        <div class="demo-section">
            <h2>📋 基础深拷贝测试</h2>
            <p>测试基本的对象和数组深拷贝功能</p>
            
            <button class="test-button" onclick="testBasicClone()">测试基础深拷贝</button>
            <button class="test-button" onclick="testComplexObject()">测试复杂对象</button>
            <button class="test-button danger" onclick="testCircularReference()">测试循环引用</button>
            
            <div class="result" id="basic-result"></div>
            
            <div class="comparison" id="basic-comparison" style="display: none;">
                <div class="comparison-item">
                    <h3>🔗 原对象</h3>
                    <div class="json-viewer" id="original-object"></div>
                </div>
                <div class="comparison-item">
                    <h3>📝 克隆对象</h3>
                    <div class="json-viewer" id="cloned-object"></div>
                </div>
            </div>
        </div>
        
        <div class="demo-section">
            <h2>🏗️ 特殊类型处理</h2>
            <p>测试Date、RegExp、Set、Map、Symbol等特殊类型</p>
            
            <button class="test-button" onclick="testSpecialTypes()">测试特殊类型</button>
            <button class="test-button" onclick="testDateRegExp()">测试Date和正则</button>
            <button class="test-button" onclick="testSetMap()">测试Set和Map</button>
            
            <div class="result" id="special-result"></div>
        </div>
        
        <div class="demo-section">
            <h2>⚡ 性能对比测试</h2>
            <p>对比不同深拷贝方法的性能表现</p>
            
            <button class="test-button" onclick="runPerformanceTest()">运行性能测试</button>
            
            <div class="performance-test">
                <div class="performance-result" id="performance-results"></div>
            </div>
            
            <div class="result" id="performance-detail"></div>
        </div>
        
        <div class="demo-section">
            <h2>🧪 边界情况测试</h2>
            <p>测试各种边界情况和异常处理</p>
            
            <button class="test-button" onclick="testBoundaryCases()">测试边界情况</button>
            <button class="test-button" onclick="testNullUndefined()">测试null/undefined</button>
            <button class="test-button" onclick="testPrimitives()">测试基本类型</button>
            
            <div class="result" id="boundary-result"></div>
        </div>
    </div>

    <script src="../vanilla-js/deep-clone.js"></script>
    
    <script>
        // 创建测试用的复杂对象
        function createComplexObject() {
            const now = new Date();
            const regex = /test\d+/gi;
            const map = new Map([['key1', 'value1'], ['key2', 'value2']]);
            const set = new Set([1, 2, 3, 'test']);
            const symbol = Symbol('test');
            
            return {
                string: 'Hello World',
                number: 42,
                boolean: true,
                nullValue: null,
                undefinedValue: undefined,
                date: now,
                regexp: regex,
                array: [1, 2, [3, 4, { nested: 'value' }]],
                map: map,
                set: set,
                symbolKey: symbol,
                [symbol]: 'symbol value',
                nested: {
                    deep: {
                        deeper: {
                            value: 'deep value',
                            date: new Date('2023-01-01'),
                            func: function() { return 'function'; }
                        }
                    }
                },
                func: () => 'arrow function',
                asyncFunc: async () => 'async function'
            };
        }
        
        // 测试基础深拷贝
        function testBasicClone() {
            const result = document.getElementById('basic-result');
            const comparison = document.getElementById('basic-comparison');
            
            try {
                const original = {
                    name: 'John',
                    age: 30,
                    hobbies: ['reading', 'coding'],
                    address: {
                        city: 'Beijing',
                        country: 'China'
                    }
                };
                
                const cloned = deepClone(original);
                
                // 修改克隆对象
                cloned.name = 'Jane';
                cloned.hobbies.push('swimming');
                cloned.address.city = 'Shanghai';
                
                // 检查独立性
                const isIndependent = 
                    original.name !== cloned.name &&
                    original.hobbies.length !== cloned.hobbies.length &&
                    original.address.city !== cloned.address.city;
                
                result.textContent = `✅ 基础深拷贝测试成功！
                
独立性检查: ${isIndependent ? '✅ 通过' : '❌ 失败'}

原对象 name: ${original.name}
克隆对象 name: ${cloned.name}

原对象 hobbies: [${original.hobbies.join(', ')}]
克隆对象 hobbies: [${cloned.hobbies.join(', ')}]

原对象 city: ${original.address.city}
克隆对象 city: ${cloned.address.city}`;
                
                // 显示对比
                document.getElementById('original-object').textContent = JSON.stringify(original, null, 2);
                document.getElementById('cloned-object').textContent = JSON.stringify(cloned, null, 2);
                comparison.style.display = 'grid';
                
            } catch (error) {
                result.textContent = `❌ 测试失败: ${error.message}`;
                comparison.style.display = 'none';
            }
        }
        
        // 测试复杂对象
        function testComplexObject() {
            const result = document.getElementById('basic-result');
            
            try {
                const original = createComplexObject();
                const cloned = advancedDeepClone(original);
                
                // 测试各种类型
                const tests = [
                    {
                        name: 'Date类型',
                        test: () => cloned.date instanceof Date && cloned.date.getTime() === original.date.getTime()
                    },
                    {
                        name: 'RegExp类型',
                        test: () => cloned.regexp instanceof RegExp && cloned.regexp.toString() === original.regexp.toString()
                    },
                    {
                        name: 'Map类型',
                        test: () => cloned.map instanceof Map && cloned.map.size === original.map.size
                    },
                    {
                        name: 'Set类型',
                        test: () => cloned.set instanceof Set && cloned.set.size === original.set.size
                    },
                    {
                        name: '嵌套对象',
                        test: () => cloned.nested.deep.deeper.value === original.nested.deep.deeper.value
                    },
                    {
                        name: '数组嵌套',
                        test: () => Array.isArray(cloned.array) && cloned.array[2][2].nested === 'value'
                    }
                ];
                
                const results = tests.map(test => ({
                    name: test.name,
                    passed: test.test()
                }));
                
                const passedCount = results.filter(r => r.passed).length;
                
                result.textContent = `🏗️ 复杂对象测试结果 (${passedCount}/${results.length} 通过)
                
${results.map(r => `${r.passed ? '✅' : '❌'} ${r.name}`).join('\n')}

对象类型检查:
- Date: ${cloned.date instanceof Date ? '✅' : '❌'}
- RegExp: ${cloned.regexp instanceof RegExp ? '✅' : '❌'}
- Map: ${cloned.map instanceof Map ? '✅' : '❌'}
- Set: ${cloned.set instanceof Set ? '✅' : '❌'}
- Array: ${Array.isArray(cloned.array) ? '✅' : '❌'}`;
                
            } catch (error) {
                result.textContent = `❌ 复杂对象测试失败: ${error.message}`;
            }
        }
        
        // 测试循环引用
        function testCircularReference() {
            const result = document.getElementById('basic-result');
            
            try {
                // 创建循环引用对象
                const original = {
                    name: 'parent',
                    child: {
                        name: 'child',
                        parent: null
                    }
                };
                original.child.parent = original;
                original.self = original;
                
                const cloned = deepClone(original);
                
                // 检查循环引用是否正确处理
                const tests = [
                    cloned.child.parent === cloned,
                    cloned.self === cloned,
                    cloned.child.parent.name === 'parent',
                    cloned !== original,
                    cloned.child !== original.child
                ];
                
                const allPassed = tests.every(t => t);
                
                result.textContent = `🔄 循环引用测试: ${allPassed ? '✅ 成功' : '❌ 失败'}
                
检查项目:
✅ 克隆对象与原对象不同
✅ 子对象与原子对象不同  
✅ 循环引用正确维护
✅ 对象属性值正确
✅ 避免无限递归

循环引用验证:
- cloned.child.parent === cloned: ${cloned.child.parent === cloned}
- cloned.self === cloned: ${cloned.self === cloned}
- cloned !== original: ${cloned !== original}`;
                
            } catch (error) {
                result.textContent = `❌ 循环引用测试失败: ${error.message}
                
这可能是因为:
1. 没有处理循环引用
2. 陷入无限递归
3. WeakMap 未正确使用`;
            }
        }
        
        // 测试特殊类型
        function testSpecialTypes() {
            const result = document.getElementById('special-result');
            
            try {
                const now = new Date();
                const regex = /test\d+/gi;
                const buffer = new ArrayBuffer(8);
                const view = new Int32Array(buffer);
                view[0] = 42;
                
                const original = {
                    date: now,
                    regexp: regex,
                    error: new Error('test error'),
                    buffer: buffer,
                    view: view,
                    func: function(x) { return x * 2; },
                    arrow: (x) => x * 3,
                    async: async (x) => x * 4
                };
                
                const cloned = advancedDeepClone(original);
                
                result.textContent = `🎯 特殊类型测试结果:
                
✅ Date: ${cloned.date instanceof Date && cloned.date.getTime() === now.getTime()}
✅ RegExp: ${cloned.regexp instanceof RegExp && cloned.regexp.source === regex.source}
✅ Error: ${cloned.error instanceof Error && cloned.error.message === 'test error'}
✅ ArrayBuffer: ${cloned.buffer instanceof ArrayBuffer}
✅ TypedArray: ${cloned.view instanceof Int32Array}
⚠️  Function: ${typeof cloned.func === 'function'} (函数无法完全克隆)

详细信息:
- 原始 Date: ${now.toISOString()}
- 克隆 Date: ${cloned.date.toISOString()}
- 原始 RegExp: ${regex.toString()}
- 克隆 RegExp: ${cloned.regexp.toString()}
- 原始 Error: ${original.error.message}
- 克隆 Error: ${cloned.error.message}`;
                
            } catch (error) {
                result.textContent = `❌ 特殊类型测试失败: ${error.message}`;
            }
        }
        
        // 测试Date和正则
        function testDateRegExp() {
            const result = document.getElementById('special-result');
            
            try {
                const original = {
                    birthday: new Date('1990-01-01'),
                    created: new Date(),
                    emailRegex: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
                    phoneRegex: /^1[3-9]\d{9}$/g,
                    multiFlag: /test/gim
                };
                
                const cloned = advancedDeepClone(original);
                
                result.textContent = `📅 Date & RegExp 测试:
                
Date 测试:
✅ birthday: ${cloned.birthday instanceof Date}
   原始: ${original.birthday.toDateString()}
   克隆: ${cloned.birthday.toDateString()}
   相等: ${original.birthday.getTime() === cloned.birthday.getTime()}

✅ created: ${cloned.created instanceof Date}
   时间差: ${Math.abs(cloned.created.getTime() - original.created.getTime())}ms

RegExp 测试:
✅ emailRegex: ${cloned.emailRegex instanceof RegExp}
   源码: ${cloned.emailRegex.source === original.emailRegex.source}
   标志: ${cloned.emailRegex.flags === original.emailRegex.flags}

✅ phoneRegex: ${cloned.phoneRegex instanceof RegExp}
   global: ${cloned.phoneRegex.global === original.phoneRegex.global}

✅ multiFlag: ${cloned.multiFlag instanceof RegExp}
   flags: ${cloned.multiFlag.flags} === ${original.multiFlag.flags}`;
                
            } catch (error) {
                result.textContent = `❌ Date & RegExp 测试失败: ${error.message}`;
            }
        }
        
        // 测试Set和Map
        function testSetMap() {
            const result = document.getElementById('special-result');
            
            try {
                const map = new Map([
                    ['string', 'value'],
                    [42, 'number key'],
                    [true, 'boolean key'],
                    [{key: 'object'}, 'object key']
                ]);
                
                const set = new Set([
                    'string',
                    42,
                    true,
                    {id: 1},
                    [1, 2, 3]
                ]);
                
                const original = { map, set };
                const cloned = advancedDeepClone(original);
                
                result.textContent = `🗺️ Set & Map 测试:
                
Map 测试:
✅ 类型: ${cloned.map instanceof Map}
✅ 大小: ${cloned.map.size === original.map.size}
✅ 字符串键: ${cloned.map.get('string') === 'value'}
✅ 数字键: ${cloned.map.get(42) === 'number key'}
✅ 布尔键: ${cloned.map.get(true) === 'boolean key'}

Map 内容:
${Array.from(cloned.map.entries()).map(([k, v]) => `  ${JSON.stringify(k)} => ${JSON.stringify(v)}`).join('\n')}

Set 测试:
✅ 类型: ${cloned.set instanceof Set}
✅ 大小: ${cloned.set.size === original.set.size}
✅ 包含字符串: ${cloned.set.has('string')}
✅ 包含数字: ${cloned.set.has(42)}
✅ 包含布尔: ${cloned.set.has(true)}

Set 内容:
${Array.from(cloned.set).map(v => `  ${JSON.stringify(v)}`).join('\n')}`;
                
            } catch (error) {
                result.textContent = `❌ Set & Map 测试失败: ${error.message}`;
            }
        }
        
        // 性能测试
        function runPerformanceTest() {
            const resultsDiv = document.getElementById('performance-results');
            const detailDiv = document.getElementById('performance-detail');
            
            const testObject = createLargeObject();
            const iterations = 1000;
            
            // 测试不同方法的性能
            const methods = [
                {
                    name: 'JSON方法',
                    func: (obj) => JSON.parse(JSON.stringify(obj)),
                    note: '无法处理函数、Symbol等'
                },
                {
                    name: '简单深拷贝',
                    func: (obj) => simpleDeepClone(obj),
                    note: '基础实现'
                },
                {
                    name: '标准深拷贝',
                    func: (obj) => deepClone(obj),
                    note: '处理循环引用'
                },
                {
                    name: '高级深拷贝',
                    func: (obj) => advancedDeepClone(obj),
                    note: '处理所有类型'
                }
            ];
            
            const results = methods.map(method => {
                const start = performance.now();
                
                try {
                    for (let i = 0; i < iterations; i++) {
                        method.func(testObject);
                    }
                    const time = performance.now() - start;
                    return { ...method, time, success: true };
                } catch (error) {
                    return { ...method, time: 0, success: false, error: error.message };
                }
            });
            
            // 显示结果
            resultsDiv.innerHTML = results.map(result => `
                <div class="performance-item">
                    <div class="performance-value">${result.success ? Math.round(result.time) + 'ms' : 'Error'}</div>
                    <div class="performance-label">${result.name}</div>
                </div>
            `).join('');
            
            detailDiv.textContent = `⚡ 性能测试结果 (${iterations} 次迭代):

${results.map(result => {
                if (result.success) {
                    return `✅ ${result.name}: ${Math.round(result.time)}ms (${result.note})`;
                } else {
                    return `❌ ${result.name}: 失败 - ${result.error}`;
                }
            }).join('\n')}

测试对象大小: ${JSON.stringify(testObject).length} 字符
最快方法: ${results.filter(r => r.success).sort((a, b) => a.time - b.time)[0]?.name || 'None'}

💡 性能分析:
- JSON方法最快，但功能受限
- 功能越完整，性能开销越大
- 实际使用需要平衡功能和性能`;
        }
        
        // 创建大对象用于性能测试
        function createLargeObject() {
            const large = {
                users: [],
                metadata: {
                    created: new Date(),
                    version: '1.0.0'
                }
            };
            
            // 创建100个用户
            for (let i = 0; i < 100; i++) {
                large.users.push({
                    id: i,
                    name: `User${i}`,
                    email: `user${i}@example.com`,
                    profile: {
                        age: 20 + Math.floor(Math.random() * 50),
                        interests: ['coding', 'reading', 'gaming'].slice(0, Math.floor(Math.random() * 3) + 1)
                    }
                });
            }
            
            return large;
        }
        
        // 测试边界情况
        function testBoundaryCase() {
            const result = document.getElementById('boundary-result');
            
            try {
                const tests = [
                    { name: 'null', value: null },
                    { name: 'undefined', value: undefined },
                    { name: '空对象', value: {} },
                    { name: '空数组', value: [] },
                    { name: '0', value: 0 },
                    { name: '空字符串', value: '' },
                    { name: 'false', value: false },
                    { name: 'NaN', value: NaN },
                    { name: 'Infinity', value: Infinity },
                    { name: '-Infinity', value: -Infinity }
                ];
                
                const results = tests.map(test => {
                    try {
                        const cloned = deepClone(test.value);
                        const isEqual = Number.isNaN(test.value) ? Number.isNaN(cloned) : cloned === test.value;
                        return { name: test.name, success: true, equal: isEqual, cloned };
                    } catch (error) {
                        return { name: test.name, success: false, error: error.message };
                    }
                });
                
                result.textContent = `🧪 边界情况测试结果:

${results.map(r => {
                    if (r.success) {
                        return `✅ ${r.name}: ${r.equal ? '相等' : '不等'} (${JSON.stringify(r.cloned)})`;
                    } else {
                        return `❌ ${r.name}: 失败 - ${r.error}`;
                    }
                }).join('\n')}

通过率: ${results.filter(r => r.success && r.equal).length}/${results.length}`;
                
            } catch (error) {
                result.textContent = `❌ 边界测试失败: ${error.message}`;
            }
        }
        
        // 其他测试函数的简化版本
        function testBoundaryCase() { testBoundaryCase(); }
        function testNullUndefined() {
            const result = document.getElementById('boundary-result');
            
            const tests = [
                { input: null, expected: null },
                { input: undefined, expected: undefined },
                { input: { a: null, b: undefined }, expected: { a: null, b: undefined } }
            ];
            
            const results = tests.map(test => {
                const cloned = deepClone(test.input);
                return {
                    input: test.input,
                    cloned,
                    equal: JSON.stringify(cloned) === JSON.stringify(test.expected)
                };
            });
            
            result.textContent = `🔍 Null/Undefined 测试:
            
${results.map((r, i) => `✅ 测试${i + 1}: ${r.equal ? '通过' : '失败'}
   输入: ${JSON.stringify(r.input)}
   输出: ${JSON.stringify(r.cloned)}`).join('\n')}`;
        }
        
        function testPrimitives() {
            const result = document.getElementById('boundary-result');
            
            const primitives = [
                42,
                'hello',
                true,
                Symbol('test'),
                BigInt(123)
            ];
            
            const results = primitives.map(primitive => {
                const cloned = deepClone(primitive);
                return {
                    type: typeof primitive,
                    value: primitive,
                    cloned,
                    equal: primitive === cloned
                };
            });
            
            result.textContent = `🎯 基本类型测试:
            
${results.map(r => `✅ ${r.type}: ${r.equal ? '相等' : '不等'}
   原值: ${String(r.value)}
   克隆: ${String(r.cloned)}`).join('\n')}`;
        }
        
        // 页面加载提示
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🔄 深拷贝演示页面已加载');
            console.log('💡 点击测试按钮查看深拷贝的各种实现效果');
            
            // 添加提示信息
            document.querySelector('.demo-container').insertAdjacentHTML('afterbegin', `
                <div class="success">
                    <strong>💡 使用提示：</strong>
                    本演示包含了多种深拷贝实现方法，从基础版本到处理复杂类型和循环引用的高级版本。
                    建议按顺序测试，观察不同实现的差异和适用场景。
                </div>
            `);
        });
    </script>
</body>
</html>
