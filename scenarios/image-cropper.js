/**
 * Âú∫ÊôØÈ¢ò13: ÂõæÁâáË£ÅÂâ™ÁªÑ‰ª∂ÂÆûÁé∞
 * 
 * ‰∏öÂä°Âú∫ÊôØÔºö
 * - Áî®Êà∑Â§¥ÂÉè‰∏ä‰º†ÂíåË£ÅÂâ™
 * - ÂïÜÂìÅÂõæÁâáÁºñËæëÂíå‰ºòÂåñ
 * - Á§æ‰∫§Â™í‰ΩìÂõæÁâáÂ§ÑÁêÜ
 * 
 * ËÄÉÂØüÁÇπÔºö
 * - Canvas API ÂíåÂõæÂÉèÂ§ÑÁêÜ
 * - Èº†Ê†á/Ëß¶Êë∏‰∫ã‰ª∂Â§ÑÁêÜ
 * - ÂùêÊ†áÂèòÊç¢ÂíåÊï∞Â≠¶ËÆ°ÁÆó
 * - File API Âíå Blob Êìç‰Ωú
 * - ÂõæÁâáÂéãÁº©ÂíåÊ†ºÂºèËΩ¨Êç¢
 */

// 1. ÂõæÁâáË£ÅÂâ™Âô®Ê†∏ÂøÉÁ±ª
class ImageCropper {
  constructor(container, options = {}) {
    this.container = typeof container === 'string' 
      ? document.querySelector(container) 
      : container;
    
    this.options = {
      aspectRatio: null,          // Ë£ÅÂâ™ÊØî‰æã (width/height)
      minWidth: 50,               // ÊúÄÂ∞èË£ÅÂâ™ÂÆΩÂ∫¶
      minHeight: 50,              // ÊúÄÂ∞èË£ÅÂâ™È´òÂ∫¶
      maxWidth: Infinity,         // ÊúÄÂ§ßË£ÅÂâ™ÂÆΩÂ∫¶
      maxHeight: Infinity,        // ÊúÄÂ§ßË£ÅÂâ™È´òÂ∫¶
      cropBoxResizable: true,     // Ë£ÅÂâ™Ê°ÜÂèØË∞ÉÊï¥Â§ßÂ∞è
      cropBoxMovable: true,       // Ë£ÅÂâ™Ê°ÜÂèØÁßªÂä®
      zoomable: true,             // ÊîØÊåÅÁº©Êîæ
      rotatable: true,            // ÊîØÊåÅÊóãËΩ¨
      scalable: true,             // ÊîØÊåÅÁøªËΩ¨
      responsive: true,           // ÂìçÂ∫îÂºè
      background: true,           // ÊòæÁ§∫ÁΩëÊ†ºËÉåÊôØ
      guides: true,               // ÊòæÁ§∫ËæÖÂä©Á∫ø
      center: true,               // Â±Ö‰∏≠ÊòæÁ§∫
      highlight: true,            // È´ò‰∫ÆË£ÅÂâ™Âå∫Âüü
      autoCrop: true,             // Ëá™Âä®Ë£ÅÂâ™
      quality: 0.9,               // ËæìÂá∫Ë¥®Èáè
      outputFormat: 'image/jpeg', // ËæìÂá∫Ê†ºÂºè
      ...options
    };
    
    this.state = {
      image: null,                // ÂéüÂßãÂõæÁâá
      canvas: null,               // ÁîªÂ∏É
      ctx: null,                  // ÁîªÂ∏É‰∏ä‰∏ãÊñá
      imageData: {                // ÂõæÁâáÊï∞ÊçÆ
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        naturalWidth: 0,
        naturalHeight: 0,
        rotate: 0,
        scaleX: 1,
        scaleY: 1
      },
      cropBox: {                  // Ë£ÅÂâ™Ê°ÜÊï∞ÊçÆ
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      container: {                // ÂÆπÂô®Êï∞ÊçÆ
        width: 0,
        height: 0
      },
      isDragging: false,          // ÊòØÂê¶ÊãñÊãΩ‰∏≠
      isResizing: false,          // ÊòØÂê¶Ë∞ÉÊï¥Â§ßÂ∞è‰∏≠
      dragStart: { x: 0, y: 0 },  // ÊãñÊãΩËµ∑ÂßãÁÇπ
      resizeHandle: null          // Ë∞ÉÊï¥Â§ßÂ∞èÊâãÊüÑ
    };
    
    this.callbacks = {
      onReady: options.onReady || (() => {}),
      onCrop: options.onCrop || (() => {}),
      onMove: options.onMove || (() => {}),
      onResize: options.onResize || (() => {}),
      onRotate: options.onRotate || (() => {}),
      onScale: options.onScale || (() => {})
    };
    
    this.elements = {};
    
    this.init();
  }
  
  init() {
    this.createElements();
    this.bindEvents();
  }
  
  // ÂàõÂª∫DOMÂÖÉÁ¥†
  createElements() {
    this.container.innerHTML = `
      <div class="image-cropper">
        <div class="cropper-container">
          <div class="cropper-canvas-container">
            <canvas class="cropper-canvas"></canvas>
          </div>
          <div class="cropper-crop-box" style="display: none;">
            <div class="cropper-view-box">
              <canvas class="cropper-preview"></canvas>
            </div>
            <div class="cropper-dashed dashed-h"></div>
            <div class="cropper-dashed dashed-v"></div>
            <div class="cropper-center"></div>
            <div class="cropper-face"></div>
            <div class="cropper-line line-e" data-direction="e"></div>
            <div class="cropper-line line-n" data-direction="n"></div>
            <div class="cropper-line line-w" data-direction="w"></div>
            <div class="cropper-line line-s" data-direction="s"></div>
            <div class="cropper-point point-e" data-direction="e"></div>
            <div class="cropper-point point-n" data-direction="n"></div>
            <div class="cropper-point point-w" data-direction="w"></div>
            <div class="cropper-point point-s" data-direction="s"></div>
            <div class="cropper-point point-ne" data-direction="ne"></div>
            <div class="cropper-point point-nw" data-direction="nw"></div>
            <div class="cropper-point point-sw" data-direction="sw"></div>
            <div class="cropper-point point-se" data-direction="se"></div>
          </div>
        </div>
        
        <div class="cropper-toolbar">
          <div class="toolbar-group">
            <button class="toolbar-btn" id="move-btn" title="ÁßªÂä®">‚úã</button>
            <button class="toolbar-btn" id="crop-btn" title="Ë£ÅÂâ™">‚úÇÔ∏è</button>
          </div>
          
          <div class="toolbar-group">
            <button class="toolbar-btn" id="zoom-in-btn" title="ÊîæÂ§ß">üîç+</button>
            <button class="toolbar-btn" id="zoom-out-btn" title="Áº©Â∞è">üîç-</button>
            <button class="toolbar-btn" id="reset-btn" title="ÈáçÁΩÆ">üîÑ</button>
          </div>
          
          <div class="toolbar-group">
            <button class="toolbar-btn" id="rotate-left-btn" title="Â∑¶ËΩ¨90¬∞">‚Ü∂</button>
            <button class="toolbar-btn" id="rotate-right-btn" title="Âè≥ËΩ¨90¬∞">‚Ü∑</button>
          </div>
          
          <div class="toolbar-group">
            <button class="toolbar-btn" id="flip-h-btn" title="Ê∞¥Âπ≥ÁøªËΩ¨">‚ÜîÔ∏è</button>
            <button class="toolbar-btn" id="flip-v-btn" title="ÂûÇÁõ¥ÁøªËΩ¨">‚ÜïÔ∏è</button>
          </div>
          
          <div class="toolbar-group">
            <select id="aspect-ratio-select" title="Ë£ÅÂâ™ÊØî‰æã">
              <option value="">Ëá™Áî±ÊØî‰æã</option>
              <option value="1">1:1 (Ê≠£ÊñπÂΩ¢)</option>
              <option value="1.33">4:3</option>
              <option value="1.78">16:9</option>
              <option value="0.75">3:4</option>
              <option value="0.56">9:16</option>
            </select>
          </div>
          
          <div class="toolbar-group">
            <button class="toolbar-btn primary" id="confirm-btn" title="Á°ÆËÆ§Ë£ÅÂâ™">‚úì Á°ÆËÆ§</button>
            <button class="toolbar-btn secondary" id="cancel-btn" title="ÂèñÊ∂à">‚úó ÂèñÊ∂à</button>
          </div>
        </div>
      </div>
    `;
    
    // ÁºìÂ≠òDOMÂÖÉÁ¥†
    this.elements = {
      container: this.container.querySelector('.cropper-container'),
      canvas: this.container.querySelector('.cropper-canvas'),
      preview: this.container.querySelector('.cropper-preview'),
      cropBox: this.container.querySelector('.cropper-crop-box'),
      viewBox: this.container.querySelector('.cropper-view-box'),
      face: this.container.querySelector('.cropper-face'),
      toolbar: this.container.querySelector('.cropper-toolbar')
    };
    
    this.state.canvas = this.elements.canvas;
    this.state.ctx = this.elements.canvas.getContext('2d');
    this.previewCtx = this.elements.preview.getContext('2d');
    
    this.addStyles();
  }
  
  // Ê∑ªÂä†Ê†∑Âºè
  addStyles() {
    if (document.getElementById('image-cropper-styles')) return;
    
    const styles = document.createElement('style');
    styles.id = 'image-cropper-styles';
    styles.textContent = `
      .image-cropper {
        font-family: Arial, sans-serif;
        background: #f8f9fa;
        border-radius: 8px;
        overflow: hidden;
      }
      
      .cropper-container {
        position: relative;
        width: 100%;
        height: 400px;
        background: #000;
        overflow: hidden;
        user-select: none;
      }
      
      .cropper-canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      
      .cropper-canvas {
        display: block;
        width: 100%;
        height: 100%;
        cursor: crosshair;
      }
      
      .cropper-crop-box {
        position: absolute;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid #39f;
        cursor: move;
      }
      
      .cropper-view-box {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
        border-radius: 50%;
      }
      
      .cropper-preview {
        display: block;
        width: 100%;
        height: 100%;
      }
      
      .cropper-dashed {
        position: absolute;
        border: 0 dashed #eee;
        opacity: 0.5;
        pointer-events: none;
      }
      
      .dashed-h {
        top: 33.33333%;
        left: 0;
        width: 100%;
        height: 33.33333%;
        border-top-width: 1px;
        border-bottom-width: 1px;
      }
      
      .dashed-v {
        top: 0;
        left: 33.33333%;
        width: 33.33333%;
        height: 100%;
        border-left-width: 1px;
        border-right-width: 1px;
      }
      
      .cropper-center {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        margin: -10px 0 0 -10px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        opacity: 0.75;
        pointer-events: none;
      }
      
      .cropper-face {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.1);
        cursor: move;
      }
      
      .cropper-line {
        position: absolute;
        background: #39f;
        opacity: 0.1;
      }
      
      .line-e {
        top: 0;
        right: -3px;
        width: 5px;
        height: 100%;
        cursor: ew-resize;
      }
      
      .line-n {
        top: -3px;
        left: 0;
        width: 100%;
        height: 5px;
        cursor: ns-resize;
      }
      
      .line-w {
        top: 0;
        left: -3px;
        width: 5px;
        height: 100%;
        cursor: ew-resize;
      }
      
      .line-s {
        bottom: -3px;
        left: 0;
        width: 100%;
        height: 5px;
        cursor: ns-resize;
      }
      
      .cropper-point {
        position: absolute;
        width: 5px;
        height: 5px;
        background: #39f;
        border-radius: 100%;
        opacity: 0.75;
      }
      
      .point-e {
        top: 50%;
        right: -3px;
        margin-top: -3px;
        cursor: ew-resize;
      }
      
      .point-n {
        top: -3px;
        left: 50%;
        margin-left: -3px;
        cursor: ns-resize;
      }
      
      .point-w {
        top: 50%;
        left: -3px;
        margin-top: -3px;
        cursor: ew-resize;
      }
      
      .point-s {
        bottom: -3px;
        left: 50%;
        margin-left: -3px;
        cursor: ns-resize;
      }
      
      .point-ne {
        top: -3px;
        right: -3px;
        cursor: nesw-resize;
      }
      
      .point-nw {
        top: -3px;
        left: -3px;
        cursor: nwse-resize;
      }
      
      .point-sw {
        bottom: -3px;
        left: -3px;
        cursor: nesw-resize;
      }
      
      .point-se {
        bottom: -3px;
        right: -3px;
        cursor: nwse-resize;
      }
      
      .cropper-toolbar {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 12px 16px;
        background: white;
        border-top: 1px solid #ddd;
        flex-wrap: wrap;
      }
      
      .toolbar-group {
        display: flex;
        gap: 4px;
        align-items: center;
      }
      
      .toolbar-btn {
        background: white;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 6px 12px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;
        min-width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .toolbar-btn:hover {
        background: #f0f0f0;
        border-color: #007bff;
      }
      
      .toolbar-btn.active {
        background: #007bff;
        color: white;
        border-color: #007bff;
      }
      
      .toolbar-btn.primary {
        background: #28a745;
        color: white;
        border-color: #28a745;
      }
      
      .toolbar-btn.secondary {
        background: #6c757d;
        color: white;
        border-color: #6c757d;
      }
      
      #aspect-ratio-select {
        padding: 6px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        min-width: 120px;
      }
      
      /* ÂìçÂ∫îÂºè */
      @media (max-width: 768px) {
        .cropper-toolbar {
          flex-direction: column;
          gap: 8px;
        }
        
        .toolbar-group {
          width: 100%;
          justify-content: center;
        }
      }
    `;
    
    document.head.appendChild(styles);
  }
  
  // ÁªëÂÆö‰∫ã‰ª∂
  bindEvents() {
    const { container, cropBox, face } = this.elements;
    
    // Èº†Ê†á‰∫ã‰ª∂
    container.addEventListener('mousedown', this.handleMouseDown.bind(this));
    document.addEventListener('mousemove', this.handleMouseMove.bind(this));
    document.addEventListener('mouseup', this.handleMouseUp.bind(this));
    
    // Ëß¶Êë∏‰∫ã‰ª∂
    container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
    document.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
    document.addEventListener('touchend', this.handleTouchEnd.bind(this));
    
    // ÊªöËΩÆÁº©Êîæ
    container.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
    
    // Â∑•ÂÖ∑Ê†èÊåâÈíÆ
    this.bindToolbarEvents();
    
    // Á™óÂè£Â§ßÂ∞èÂèòÂåñ
    window.addEventListener('resize', this.handleResize.bind(this));
  }
  
  // ÁªëÂÆöÂ∑•ÂÖ∑Ê†è‰∫ã‰ª∂
  bindToolbarEvents() {
    document.getElementById('move-btn').addEventListener('click', () => {
      this.setDragMode('move');
    });
    
    document.getElementById('crop-btn').addEventListener('click', () => {
      this.setDragMode('crop');
    });
    
    document.getElementById('zoom-in-btn').addEventListener('click', () => {
      this.zoom(0.1);
    });
    
    document.getElementById('zoom-out-btn').addEventListener('click', () => {
      this.zoom(-0.1);
    });
    
    document.getElementById('reset-btn').addEventListener('click', () => {
      this.reset();
    });
    
    document.getElementById('rotate-left-btn').addEventListener('click', () => {
      this.rotate(-90);
    });
    
    document.getElementById('rotate-right-btn').addEventListener('click', () => {
      this.rotate(90);
    });
    
    document.getElementById('flip-h-btn').addEventListener('click', () => {
      this.scaleX(-this.state.imageData.scaleX);
    });
    
    document.getElementById('flip-v-btn').addEventListener('click', () => {
      this.scaleY(-this.state.imageData.scaleY);
    });
    
    document.getElementById('aspect-ratio-select').addEventListener('change', (e) => {
      const ratio = e.target.value ? parseFloat(e.target.value) : null;
      this.setAspectRatio(ratio);
    });
    
    document.getElementById('confirm-btn').addEventListener('click', () => {
      this.getCroppedCanvas().then(canvas => {
        this.callbacks.onCrop(canvas);
      });
    });
    
    document.getElementById('cancel-btn').addEventListener('click', () => {
      this.reset();
    });
  }
  
  // Â§ÑÁêÜÈº†Ê†áÊåâ‰∏ã
  handleMouseDown(e) {
    if (e.button !== 0) return; // Âè™Â§ÑÁêÜÂ∑¶ÈîÆ
    
    e.preventDefault();
    
    const rect = this.elements.container.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    this.startDrag(x, y, e.target);
  }
  
  // Â§ÑÁêÜËß¶Êë∏ÂºÄÂßã
  handleTouchStart(e) {
    e.preventDefault();
    
    if (e.touches.length === 1) {
      const touch = e.touches[0];
      const rect = this.elements.container.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      
      this.startDrag(x, y, e.target);
    }
  }
  
  // ÂºÄÂßãÊãñÊãΩ
  startDrag(x, y, target) {
    this.state.dragStart = { x, y };
    
    if (target.classList.contains('cropper-point') || target.classList.contains('cropper-line')) {
      this.state.isResizing = true;
      this.state.resizeHandle = target.dataset.direction;
    } else if (target.classList.contains('cropper-face')) {
      this.state.isDragging = true;
    } else {
      // ÂºÄÂßãÂàõÂª∫Êñ∞ÁöÑË£ÅÂâ™Ê°Ü
      this.createCropBox(x, y);
    }
  }
  
  // Â§ÑÁêÜÈº†Ê†áÁßªÂä®
  handleMouseMove(e) {
    if (!this.state.isDragging && !this.state.isResizing) return;
    
    const rect = this.elements.container.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    this.drag(x, y);
  }
  
  // Â§ÑÁêÜËß¶Êë∏ÁßªÂä®
  handleTouchMove(e) {
    if (!this.state.isDragging && !this.state.isResizing) return;
    
    e.preventDefault();
    
    const touch = e.touches[0];
    const rect = this.elements.container.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    
    this.drag(x, y);
  }
  
  // ÊãñÊãΩÂ§ÑÁêÜ
  drag(x, y) {
    const deltaX = x - this.state.dragStart.x;
    const deltaY = y - this.state.dragStart.y;
    
    if (this.state.isDragging) {
      this.moveCropBox(deltaX, deltaY);
    } else if (this.state.isResizing) {
      this.resizeCropBox(deltaX, deltaY);
    }
    
    this.state.dragStart = { x, y };
  }
  
  // Â§ÑÁêÜÈº†Ê†áÈáäÊîæ
  handleMouseUp() {
    this.endDrag();
  }
  
  // Â§ÑÁêÜËß¶Êë∏ÁªìÊùü
  handleTouchEnd() {
    this.endDrag();
  }
  
  // ÁªìÊùüÊãñÊãΩ
  endDrag() {
    this.state.isDragging = false;
    this.state.isResizing = false;
    this.state.resizeHandle = null;
  }
  
  // Â§ÑÁêÜÊªöËΩÆÁº©Êîæ
  handleWheel(e) {
    if (!this.options.zoomable) return;
    
    e.preventDefault();
    
    const delta = e.deltaY > 0 ? -0.1 : 0.1;
    this.zoom(delta);
  }
  
  // Â§ÑÁêÜÁ™óÂè£Â§ßÂ∞èÂèòÂåñ
  handleResize() {
    if (this.options.responsive) {
      this.resize();
    }
  }
  
  // Âä†ËΩΩÂõæÁâá
  loadImage(source) {
    return new Promise((resolve, reject) => {
      const image = new Image();
      
      image.onload = () => {
        this.state.image = image;
        this.initializeCanvas();
        this.initializeCropBox();
        this.render();
        this.callbacks.onReady(this);
        resolve(this);
      };
      
      image.onerror = reject;
      
      if (typeof source === 'string') {
        image.src = source;
      } else if (source instanceof File) {
        const reader = new FileReader();
        reader.onload = (e) => {
          image.src = e.target.result;
        };
        reader.readAsDataURL(source);
      } else if (source instanceof HTMLImageElement) {
        if (source.complete) {
          this.state.image = source;
          this.initializeCanvas();
          this.initializeCropBox();
          this.render();
          this.callbacks.onReady(this);
          resolve(this);
        } else {
          image.src = source.src;
        }
      }
    });
  }
  
  // ÂàùÂßãÂåñÁîªÂ∏É
  initializeCanvas() {
    const { image } = this.state;
    const container = this.elements.container;
    
    // ËÆæÁΩÆÂÆπÂô®Â∞∫ÂØ∏
    this.state.container.width = container.clientWidth;
    this.state.container.height = container.clientHeight;
    
    // ËÆ°ÁÆóÂõæÁâáÈÄÇÈÖçÂ∞∫ÂØ∏
    const scale = Math.min(
      this.state.container.width / image.naturalWidth,
      this.state.container.height / image.naturalHeight
    );
    
    this.state.imageData = {
      x: (this.state.container.width - image.naturalWidth * scale) / 2,
      y: (this.state.container.height - image.naturalHeight * scale) / 2,
      width: image.naturalWidth * scale,
      height: image.naturalHeight * scale,
      naturalWidth: image.naturalWidth,
      naturalHeight: image.naturalHeight,
      rotate: 0,
      scaleX: 1,
      scaleY: 1
    };
    
    // ËÆæÁΩÆÁîªÂ∏ÉÂ∞∫ÂØ∏
    this.state.canvas.width = this.state.container.width;
    this.state.canvas.height = this.state.container.height;
  }
  
  // ÂàùÂßãÂåñË£ÅÂâ™Ê°Ü
  initializeCropBox() {
    if (!this.options.autoCrop) return;
    
    const { imageData } = this.state;
    const size = Math.min(imageData.width, imageData.height) * 0.8;
    
    this.state.cropBox = {
      x: imageData.x + (imageData.width - size) / 2,
      y: imageData.y + (imageData.height - size) / 2,
      width: size,
      height: size
    };
    
    this.updateCropBox();
    this.elements.cropBox.style.display = 'block';
  }
  
  // ÂàõÂª∫Ë£ÅÂâ™Ê°Ü
  createCropBox(x, y) {
    this.state.cropBox = { x, y, width: 0, height: 0 };
    this.state.isDragging = true;
    this.elements.cropBox.style.display = 'block';
  }
  
  // ÁßªÂä®Ë£ÅÂâ™Ê°Ü
  moveCropBox(deltaX, deltaY) {
    const { cropBox, imageData } = this.state;
    
    let newX = cropBox.x + deltaX;
    let newY = cropBox.y + deltaY;
    
    // ËæπÁïåÈôêÂà∂
    newX = Math.max(imageData.x, Math.min(newX, imageData.x + imageData.width - cropBox.width));
    newY = Math.max(imageData.y, Math.min(newY, imageData.y + imageData.height - cropBox.height));
    
    this.state.cropBox.x = newX;
    this.state.cropBox.y = newY;
    
    this.updateCropBox();
    this.updatePreview();
    this.callbacks.onMove(this.getCropBoxData());
  }
  
  // Ë∞ÉÊï¥Ë£ÅÂâ™Ê°ÜÂ§ßÂ∞è
  resizeCropBox(deltaX, deltaY) {
    const { cropBox } = this.state;
    const { resizeHandle } = this.state;
    
    let newX = cropBox.x;
    let newY = cropBox.y;
    let newWidth = cropBox.width;
    let newHeight = cropBox.height;
    
    // Ê†πÊçÆË∞ÉÊï¥ÊâãÊüÑÊñπÂêëË∞ÉÊï¥Â∞∫ÂØ∏
    switch (resizeHandle) {
      case 'e':
        newWidth += deltaX;
        break;
      case 'w':
        newX += deltaX;
        newWidth -= deltaX;
        break;
      case 's':
        newHeight += deltaY;
        break;
      case 'n':
        newY += deltaY;
        newHeight -= deltaY;
        break;
      case 'se':
        newWidth += deltaX;
        newHeight += deltaY;
        break;
      case 'sw':
        newX += deltaX;
        newWidth -= deltaX;
        newHeight += deltaY;
        break;
      case 'ne':
        newWidth += deltaX;
        newY += deltaY;
        newHeight -= deltaY;
        break;
      case 'nw':
        newX += deltaX;
        newWidth -= deltaX;
        newY += deltaY;
        newHeight -= deltaY;
        break;
    }
    
    // Â∫îÁî®ÂÆΩÈ´òÊØîÁ∫¶Êùü
    if (this.options.aspectRatio) {
      if (resizeHandle.includes('e') || resizeHandle.includes('w')) {
        newHeight = newWidth / this.options.aspectRatio;
      } else {
        newWidth = newHeight * this.options.aspectRatio;
      }
    }
    
    // Â∞∫ÂØ∏ÈôêÂà∂
    newWidth = Math.max(this.options.minWidth, Math.min(newWidth, this.options.maxWidth));
    newHeight = Math.max(this.options.minHeight, Math.min(newHeight, this.options.maxHeight));
    
    // ËæπÁïåÈôêÂà∂
    const { imageData } = this.state;
    newX = Math.max(imageData.x, Math.min(newX, imageData.x + imageData.width - newWidth));
    newY = Math.max(imageData.y, Math.min(newY, imageData.y + imageData.height - newHeight));
    
    this.state.cropBox = { x: newX, y: newY, width: newWidth, height: newHeight };
    
    this.updateCropBox();
    this.updatePreview();
    this.callbacks.onResize(this.getCropBoxData());
  }
  
  // Êõ¥Êñ∞Ë£ÅÂâ™Ê°ÜÊòæÁ§∫
  updateCropBox() {
    const { cropBox } = this.state;
    const { cropBox: element } = this.elements;
    
    element.style.left = cropBox.x + 'px';
    element.style.top = cropBox.y + 'px';
    element.style.width = cropBox.width + 'px';
    element.style.height = cropBox.height + 'px';
  }
  
  // Êõ¥Êñ∞È¢ÑËßà
  updatePreview() {
    const { cropBox, imageData } = this.state;
    const preview = this.elements.preview;
    
    // ËÆæÁΩÆÈ¢ÑËßàÁîªÂ∏ÉÂ∞∫ÂØ∏
    const previewSize = Math.min(cropBox.width, cropBox.height);
    preview.width = previewSize;
    preview.height = previewSize;
    
    // ËÆ°ÁÆóË£ÅÂâ™Âå∫ÂüüÂú®ÂéüÂõæ‰∏≠ÁöÑ‰ΩçÁΩÆ
    const scaleX = imageData.naturalWidth / imageData.width;
    const scaleY = imageData.naturalHeight / imageData.height;
    
    const sourceX = (cropBox.x - imageData.x) * scaleX;
    const sourceY = (cropBox.y - imageData.y) * scaleY;
    const sourceWidth = cropBox.width * scaleX;
    const sourceHeight = cropBox.height * scaleY;
    
    // ÁªòÂà∂È¢ÑËßà
    this.previewCtx.clearRect(0, 0, previewSize, previewSize);
    this.previewCtx.drawImage(
      this.state.image,
      sourceX, sourceY, sourceWidth, sourceHeight,
      0, 0, previewSize, previewSize
    );
  }
  
  // Ê∏≤ÊüìÁîªÂ∏É
  render() {
    const { canvas, ctx, imageData, image } = this.state;
    
    // Ê∏ÖÁ©∫ÁîªÂ∏É
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ‰øùÂ≠ò‰∏ä‰∏ãÊñáÁä∂ÊÄÅ
    ctx.save();
    
    // ËÆæÁΩÆÂèòÊç¢
    ctx.translate(imageData.x + imageData.width / 2, imageData.y + imageData.height / 2);
    ctx.rotate(imageData.rotate * Math.PI / 180);
    ctx.scale(imageData.scaleX, imageData.scaleY);
    
    // ÁªòÂà∂ÂõæÁâá
    ctx.drawImage(
      image,
      -imageData.width / 2,
      -imageData.height / 2,
      imageData.width,
      imageData.height
    );
    
    // ÊÅ¢Â§ç‰∏ä‰∏ãÊñáÁä∂ÊÄÅ
    ctx.restore();
    
    // Êõ¥Êñ∞È¢ÑËßà
    if (this.elements.cropBox.style.display !== 'none') {
      this.updatePreview();
    }
  }
  
  // Áº©Êîæ
  zoom(ratio) {
    const { imageData } = this.state;
    
    const newWidth = imageData.width * (1 + ratio);
    const newHeight = imageData.height * (1 + ratio);
    
    // ÈôêÂà∂Áº©ÊîæËåÉÂõ¥
    if (newWidth < 50 || newHeight < 50 || newWidth > 3000 || newHeight > 3000) {
      return;
    }
    
    const deltaX = (newWidth - imageData.width) / 2;
    const deltaY = (newHeight - imageData.height) / 2;
    
    imageData.x -= deltaX;
    imageData.y -= deltaY;
    imageData.width = newWidth;
    imageData.height = newHeight;
    
    this.render();
  }
  
  // ÊóãËΩ¨
  rotate(degree) {
    this.state.imageData.rotate += degree;
    this.render();
    this.callbacks.onRotate(this.state.imageData.rotate);
  }
  
  // Ê∞¥Âπ≥ÁøªËΩ¨
  scaleX(scaleX) {
    this.state.imageData.scaleX = scaleX;
    this.render();
    this.callbacks.onScale(this.state.imageData.scaleX, this.state.imageData.scaleY);
  }
  
  // ÂûÇÁõ¥ÁøªËΩ¨
  scaleY(scaleY) {
    this.state.imageData.scaleY = scaleY;
    this.render();
    this.callbacks.onScale(this.state.imageData.scaleX, this.state.imageData.scaleY);
  }
  
  // ËÆæÁΩÆÂÆΩÈ´òÊØî
  setAspectRatio(aspectRatio) {
    this.options.aspectRatio = aspectRatio;
    
    if (aspectRatio && this.state.cropBox.width > 0) {
      // Ë∞ÉÊï¥Áé∞ÊúâË£ÅÂâ™Ê°Ü
      const { cropBox } = this.state;
      cropBox.height = cropBox.width / aspectRatio;
      this.updateCropBox();
      this.updatePreview();
    }
  }
  
  // ËÆæÁΩÆÊãñÊãΩÊ®°Âºè
  setDragMode(mode) {
    // ËøôÈáåÂèØ‰ª•ÂÆûÁé∞‰∏çÂêåÁöÑÊãñÊãΩÊ®°Âºè
    console.log('ËÆæÁΩÆÊãñÊãΩÊ®°Âºè:', mode);
  }
  
  // ÈáçÁΩÆ
  reset() {
    if (this.state.image) {
      this.initializeCanvas();
      this.initializeCropBox();
      this.render();
    }
  }
  
  // Ë∞ÉÊï¥Â§ßÂ∞è
  resize() {
    if (this.state.image) {
      this.initializeCanvas();
      this.render();
    }
  }
  
  // Ëé∑ÂèñË£ÅÂâ™Ê°ÜÊï∞ÊçÆ
  getCropBoxData() {
    const { cropBox, imageData } = this.state;
    
    // ËΩ¨Êç¢‰∏∫Áõ∏ÂØπ‰∫éÂéüÂõæÁöÑÂùêÊ†á
    const scaleX = imageData.naturalWidth / imageData.width;
    const scaleY = imageData.naturalHeight / imageData.height;
    
    return {
      x: (cropBox.x - imageData.x) * scaleX,
      y: (cropBox.y - imageData.y) * scaleY,
      width: cropBox.width * scaleX,
      height: cropBox.height * scaleY
    };
  }
  
  // Ëé∑ÂèñË£ÅÂâ™ÂêéÁöÑÁîªÂ∏É
  getCroppedCanvas(options = {}) {
    return new Promise((resolve) => {
      const {
        width = this.state.cropBox.width,
        height = this.state.cropBox.height,
        fillColor = 'white'
      } = options;
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = width;
      canvas.height = height;
      
      // Â°´ÂÖÖËÉåÊôØËâ≤
      if (fillColor) {
        ctx.fillStyle = fillColor;
        ctx.fillRect(0, 0, width, height);
      }
      
      const cropData = this.getCropBoxData();
      
      // ÁªòÂà∂Ë£ÅÂâ™ÂêéÁöÑÂõæÁâá
      ctx.drawImage(
        this.state.image,
        cropData.x, cropData.y, cropData.width, cropData.height,
        0, 0, width, height
      );
      
      resolve(canvas);
    });
  }
  
  // Ëé∑ÂèñË£ÅÂâ™ÂêéÁöÑBlob
  getCroppedBlob(options = {}) {
    return this.getCroppedCanvas(options).then(canvas => {
      return new Promise(resolve => {
        canvas.toBlob(resolve, this.options.outputFormat, this.options.quality);
      });
    });
  }
  
  // ÈîÄÊØÅË£ÅÂâ™Âô®
  destroy() {
    // ÁßªÈô§‰∫ã‰ª∂ÁõëÂê¨Âô®
    window.removeEventListener('resize', this.handleResize);
    
    // Ê∏ÖÁ©∫ÂÆπÂô®
    this.container.innerHTML = '';
  }
}

// 2. ÊºîÁ§∫Â∫îÁî®
class ImageCropperDemo {
  constructor() {
    this.cropper = null;
    this.setupUI();
    this.bindEvents();
  }
  
  setupUI() {
    document.body.innerHTML = `
      <div style="max-width: 1000px; margin: 0 auto; padding: 20px; font-family: Arial, sans-serif;">
        <h1>ÂõæÁâáË£ÅÂâ™Âô®ÊºîÁ§∫</h1>
        
        <div style="margin-bottom: 20px;">
          <input type="file" id="image-input" accept="image/*" style="margin-right: 12px;">
          <button id="load-sample" class="demo-btn">Âä†ËΩΩÁ§∫‰æãÂõæÁâá</button>
          <button id="download-result" class="demo-btn" disabled>‰∏ãËΩΩË£ÅÂâ™ÁªìÊûú</button>
        </div>
        
        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px;">
          <div>
            <div id="cropper-container" style="border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">
              <div style="padding: 40px; text-align: center; color: #666;">
                ËØ∑ÈÄâÊã©ÂõæÁâáÂºÄÂßãË£ÅÂâ™
              </div>
            </div>
          </div>
          
          <div>
            <h3>Ë£ÅÂâ™ÁªìÊûúÈ¢ÑËßà</h3>
            <div id="result-preview" style="
              width: 200px;
              height: 200px;
              border: 2px dashed #ddd;
              border-radius: 8px;
              display: flex;
              align-items: center;
              justify-content: center;
              color: #999;
              margin-bottom: 20px;
            ">
              Ë£ÅÂâ™È¢ÑËßà
            </div>
            
            <h3>Ë£ÅÂâ™‰ø°ÊÅØ</h3>
            <div id="crop-info" style="
              background: #f8f9fa;
              padding: 16px;
              border-radius: 8px;
              font-size: 14px;
              font-family: monospace;
            ">
              <div>X: 0</div>
              <div>Y: 0</div>
              <div>ÂÆΩÂ∫¶: 0</div>
              <div>È´òÂ∫¶: 0</div>
              <div>ÊóãËΩ¨: 0¬∞</div>
              <div>Áº©Êîæ: 1x</div>
            </div>
            
            <h3>Âø´Êç∑Êìç‰Ωú</h3>
            <div style="display: flex; flex-direction: column; gap: 8px;">
              <button class="quick-btn" data-ratio="">Ëá™Áî±ÊØî‰æã</button>
              <button class="quick-btn" data-ratio="1">1:1 Ê≠£ÊñπÂΩ¢</button>
              <button class="quick-btn" data-ratio="1.33">4:3 Ê®™Âêë</button>
              <button class="quick-btn" data-ratio="0.75">3:4 Á´ñÂêë</button>
              <button class="quick-btn" data-ratio="1.78">16:9 ÂÆΩÂ±è</button>
            </div>
          </div>
        </div>
        
        <div style="margin-top: 20px;">
          <h3>ÂäüËÉΩÁâπÁÇπ</h3>
          <div style="
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            font-size: 14px;
          ">
            <div>‚úì ÊîØÊåÅÈº†Ê†áÂíåËß¶Êë∏Êìç‰Ωú</div>
            <div>‚úì Ëá™Áî±Ë∞ÉÊï¥Ë£ÅÂâ™Ê°ÜÂ§ßÂ∞è</div>
            <div>‚úì Â§öÁßçÂÆΩÈ´òÊØîÈ¢ÑËÆæ</div>
            <div>‚úì ÂõæÁâáÁº©ÊîæÂíåÊóãËΩ¨</div>
            <div>‚úì Ê∞¥Âπ≥/ÂûÇÁõ¥ÁøªËΩ¨</div>
            <div>‚úì ÂÆûÊó∂È¢ÑËßàÊïàÊûú</div>
            <div>‚úì È´òË¥®ÈáèËæìÂá∫</div>
            <div>‚úì ÁßªÂä®Á´ØÈÄÇÈÖç</div>
          </div>
        </div>
      </div>
      
      <style>
        .demo-btn, .quick-btn {
          padding: 8px 16px;
          border: 1px solid #ddd;
          border-radius: 4px;
          background: white;
          cursor: pointer;
          font-size: 14px;
          transition: all 0.2s;
        }
        
        .demo-btn:hover, .quick-btn:hover {
          background: #f0f0f0;
          border-color: #007bff;
        }
        
        .demo-btn:disabled {
          opacity: 0.6;
          cursor: not-allowed;
        }
        
        .quick-btn {
          text-align: left;
          width: 100%;
        }
        
        .quick-btn.active {
          background: #007bff;
          color: white;
          border-color: #007bff;
        }
      </style>
    `;
  }
  
  bindEvents() {
    // Êñá‰ª∂ÈÄâÊã©
    document.getElementById('image-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        this.loadImage(file);
      }
    });
    
    // Âä†ËΩΩÁ§∫‰æãÂõæÁâá
    document.getElementById('load-sample').addEventListener('click', () => {
      this.loadSampleImage();
    });
    
    // ‰∏ãËΩΩÁªìÊûú
    document.getElementById('download-result').addEventListener('click', () => {
      this.downloadResult();
    });
    
    // Âø´Êç∑ÊØî‰æãÊåâÈíÆ
    document.querySelectorAll('.quick-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const ratio = e.target.dataset.ratio;
        this.setAspectRatio(ratio ? parseFloat(ratio) : null);
        
        // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
        document.querySelectorAll('.quick-btn').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
      });
    });
  }
  
  loadImage(source) {
    // ÂàùÂßãÂåñË£ÅÂâ™Âô®
    this.cropper = new ImageCropper('#cropper-container', {
      aspectRatio: null,
      autoCrop: true,
      responsive: true,
      onReady: () => {
        console.log('Ë£ÅÂâ™Âô®Â∑≤ÂáÜÂ§áÂ∞±Áª™');
        document.getElementById('download-result').disabled = false;
        this.updateCropInfo();
      },
      onCrop: (canvas) => {
        this.updateResultPreview(canvas);
      },
      onMove: (data) => {
        this.updateCropInfo(data);
      },
      onResize: (data) => {
        this.updateCropInfo(data);
      },
      onRotate: (degree) => {
        this.updateCropInfo();
      },
      onScale: (scaleX, scaleY) => {
        this.updateCropInfo();
      }
    });
    
    this.cropper.loadImage(source);
  }
  
  loadSampleImage() {
    // ÂàõÂª∫Á§∫‰æãÂõæÁâá
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = 800;
    canvas.height = 600;
    
    // ÁªòÂà∂Ê∏êÂèòËÉåÊôØ
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, '#ff6b6b');
    gradient.addColorStop(0.5, '#4ecdc4');
    gradient.addColorStop(1, '#45b7d1');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ÁªòÂà∂‰∏Ä‰∫õÂõæÂΩ¢
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.fillRect(100, 100, 200, 150);
    ctx.fillRect(500, 200, 150, 200);
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.font = '48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Á§∫‰æãÂõæÁâá', canvas.width / 2, canvas.height / 2);
    
    ctx.font = '24px Arial';
    ctx.fillText('ËØ∑Â∞ùËØïË£ÅÂâ™ÂäüËÉΩ', canvas.width / 2, canvas.height / 2 + 60);
    
    // ËΩ¨Êç¢‰∏∫ÂõæÁâáÂπ∂Âä†ËΩΩ
    canvas.toBlob((blob) => {
      this.loadImage(blob);
    });
  }
  
  setAspectRatio(ratio) {
    if (this.cropper) {
      this.cropper.setAspectRatio(ratio);
    }
  }
  
  updateResultPreview(canvas) {
    const preview = document.getElementById('result-preview');
    
    // Ê∏ÖÁ©∫È¢ÑËßàÂå∫Âüü
    preview.innerHTML = '';
    
    // ÂàõÂª∫È¢ÑËßàÂõæÁâá
    const img = document.createElement('img');
    img.src = canvas.toDataURL();
    img.style.cssText = `
      max-width: 100%;
      max-height: 100%;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    `;
    
    preview.appendChild(img);
  }
  
  updateCropInfo(data) {
    if (!this.cropper) return;
    
    const cropData = data || this.cropper.getCropBoxData();
    const imageData = this.cropper.state.imageData;
    
    document.getElementById('crop-info').innerHTML = `
      <div>X: ${Math.round(cropData.x)}</div>
      <div>Y: ${Math.round(cropData.y)}</div>
      <div>ÂÆΩÂ∫¶: ${Math.round(cropData.width)}</div>
      <div>È´òÂ∫¶: ${Math.round(cropData.height)}</div>
      <div>ÊóãËΩ¨: ${imageData.rotate}¬∞</div>
      <div>Áº©Êîæ: ${imageData.scaleX.toFixed(2)}x</div>
    `;
  }
  
  async downloadResult() {
    if (!this.cropper) return;
    
    try {
      const canvas = await this.cropper.getCroppedCanvas({
        width: 400,
        height: 400
      });
      
      // ÂàõÂª∫‰∏ãËΩΩÈìæÊé•
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `cropped-image-${Date.now()}.jpg`;
        a.click();
        URL.revokeObjectURL(url);
      }, 'image/jpeg', 0.9);
      
    } catch (error) {
      console.error('‰∏ãËΩΩÂ§±Ë¥•:', error);
      alert('‰∏ãËΩΩÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
    }
  }
}

// ËøêË°åÊºîÁ§∫
console.log('=== ÂõæÁâáË£ÅÂâ™ÁªÑ‰ª∂ÊµãËØï ===\n');

const demo = new ImageCropperDemo();

console.log('ÂõæÁâáË£ÅÂâ™ÁªÑ‰ª∂ÂäüËÉΩÁâπÁÇπÔºö');
console.log('‚úì Ëá™Áî±Ë∞ÉÊï¥Ë£ÅÂâ™Ê°ÜÂ§ßÂ∞èÂíå‰ΩçÁΩÆ');
console.log('‚úì Â§öÁßçÂÆΩÈ´òÊØîÈ¢ÑËÆæ');
console.log('‚úì ÂõæÁâáÁº©Êîæ„ÄÅÊóãËΩ¨„ÄÅÁøªËΩ¨');
console.log('‚úì ÂÆûÊó∂È¢ÑËßàÂíåÈ´òË¥®ÈáèËæìÂá∫');
console.log('‚úì Èº†Ê†áÂíåËß¶Êë∏‰∫ã‰ª∂ÊîØÊåÅ');
console.log('‚úì ÂìçÂ∫îÂºèËÆæËÆ°');
console.log('‚úì Canvas È´òÊÄßËÉΩÊ∏≤Êüì');
console.log('‚úì ÂèØËá™ÂÆö‰πâÁöÑÂ∑•ÂÖ∑Ê†è');

// ÂØºÂá∫
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    ImageCropper
  };
}
